// API Configuration
const API_BASE_URL = 'http://localhost:8000';

// Demo responses for video recording
let demoResponseCount = 0;

const demoResponses = [
    `**AI Model Analysis:**
The specialized skin disease detection model analyzed your image and provided these predictions:
  - Acne and Rosacea: 87.3% confidence
  - Eczema: 6.2% confidence
  - Allergic Contact Dermatitis: 3.8% confidence
  - Seborrheic Dermatitis: 1.9% confidence
  - Psoriasis: 0.8% confidence

**Your Symptoms:** Red itches on face

**Reasoning:** The AI model has identified this pattern with 87.3% confidence based on visual features in the image. The model was trained on thousands of dermatological images to recognize patterns associated with various skin conditions.

The image shows multiple characteristics consistent with inflammatory acne combined with post-inflammatory erythema (PIE):

1. **Visible red spots and patches** - These appear as erythematous (reddened) areas on the facial skin, particularly noticeable on the cheek area
2. **Texture irregularities** - The skin surface shows some roughness and inflammation
3. **Distribution pattern** - The condition is scattered across the facial area, which is typical for acne-related conditions
4. **Itching sensation** - Your reported symptom of "red itches" aligns with inflammatory skin conditions

This appears consistent with active or recently active acne lesions that have left behind redness. The itching you're experiencing could be due to:
- Inflammation in the affected areas
- Healing process of previous acne lesions
- Potential mild allergic or sensitivity reaction
- Compromised skin barrier function

**General Recommendations:**

1. ðŸ§¼ **Gentle Cleansing**
   - Use a mild, fragrance-free cleanser twice daily
   - Avoid harsh scrubbing which can worsen inflammation
   - Pat dry gently with a clean towel

2. ðŸš« **Avoid Triggers**
   - Do NOT scratch or pick at the affected areas
   - Avoid touching your face frequently
   - Keep hair and hair products away from affected areas

3. ðŸ’§ **Moisturize**
   - Use a non-comedogenic (won't clog pores) moisturizer
   - Look for products with ceramides or hyaluronic acid
   - Avoid heavy, oil-based products

4. â˜€ï¸ **Sun Protection**
   - Use a mineral-based SPF 30+ sunscreen daily
   - Sun exposure can worsen redness and slow healing
   - Reapply every 2 hours if outdoors

5. ðŸ§Š **Soothing Care**
   - Apply cool (not ice-cold) compresses for 10 minutes if itching is severe
   - Consider products with niacinamide or centella asiatica (calming ingredients)

6. ðŸ“¸ **Document Progress**
   - Take photos weekly in the same lighting
   - Track which products you're using
   - Note any changes in symptoms

7. ðŸ©º **Consult a Dermatologist**
   - They can provide prescription treatments if needed
   - Options might include topical retinoids, azelaic acid, or antibiotics
   - Professional guidance ensures safe, effective treatment

**What NOT to Do:**
- âŒ Don't use toothpaste, lemon, or other home remedies
- âŒ Avoid over-washing (can dry skin and worsen condition)
- âŒ Don't start multiple new products at once
- âŒ Avoid steaming or very hot water on your face

**Timeline Expectations:**
- Post-inflammatory redness can take 3-6 months to fade naturally
- With proper treatment, you may see improvement in 4-8 weeks
- Consistency is key - stick with your routine

**Note:** This is an AI-based educational analysis. I recommend consulting a certified dermatologist for a precise diagnosis and personalized treatment plan. They can assess whether you need prescription medications or if over-the-counter products will suffice.`,

    `The latest image analysis shows significant improvement in your facial skin condition. The AI model's current assessment indicates:
- Reduced inflammatory activity (confidence in acne/rosacea decreased to 34.2%)
- Improved skin texture and tone
- Marked reduction in visible erythema (redness)
- Smoother skin surface with less irregularity

**Comparison with Previous Entries:**

**Baseline (6 weeks ago) vs. Current:**
- **Visual Similarity Score:** 45.8% (Lower similarity indicates significant change)
- **Healing Percentage:** 72.4%
- **Disease Prediction Change:** Acne/Rosacea 87.3% â†’ 34.2%
- **Visible Improvements:**
  - Red patches have faded considerably
  - Skin texture appears smoother
  - Overall inflammation reduced
  - More even skin tone

**Healing Progress:**
- **Overall Score: 72.4%**
- **Trend: IMPROVING** âœ…

The healing score of 72.4% indicates substantial positive changes between your baseline and current images. This score is calculated using advanced AI image embeddings that analyze:
- Color and pigmentation changes
- Texture and surface smoothness
- Inflammatory markers (redness, swelling)
- Overall skin appearance

A score above 70% is considered excellent progress, suggesting that your treatment regimen and skincare routine are working effectively.

**Clinical Observations:**

1. **Significant Reduction in Erythema (Redness)**
   - The prominent red patches visible in your baseline image have faded by approximately 65-70%
   - Remaining slight redness is likely residual post-inflammatory erythema that will continue to fade
   - This indicates successful reduction of inflammation

2. **Improved Skin Texture**
   - The skin surface appears noticeably smoother
   - Reduced roughness and irregularity
   - Better light reflection suggesting improved skin barrier function

3. **No New Active Lesions**
   - The current image shows no signs of new inflammatory acne
   - This suggests your current routine is preventing new breakouts
   - Preventive measures are working

**Recommendations:**

1. **Continue Current Routine**
   - Whatever you've been doing is working well - maintain consistency
   - Don't change multiple products at once to maintain this progress
   - Document what has been most effective for future reference

2. **Focus on Hyperpigmentation Fading**
   - Since active inflammation is controlled, focus on fading residual marks
   - Consider products with:
     - Vitamin C (brightening)
     - Niacinamide (reduces redness)
     - Alpha hydroxy acids/AHAs (gentle exfoliation)
     - Sunscreen is CRUCIAL - prevents darkening of marks

3. **Maintain Gentle Care**
   - Continue gentle cleansing twice daily
   - Keep up with moisturizing
   - Don't be tempted to "overtreat" now that it's improving
   - Patience - remaining redness may take another 2-3 months to completely fade

4. **Progressive Monitoring**
   - Take another progress photo in 4 weeks
   - Continue tracking improvements
   - Adjust routine only if needed (if progress stalls)

**Next Steps:**
- Take your next follow-up photo in 4 weeks
- Monitor for any new breakouts or changes
- If improvement continues at this rate, remaining redness should fade within 2-3 months
- Consider scheduling a dermatologist visit if you want to accelerate the fading of residual marks (they may offer treatments like chemical peels, laser therapy, or prescription creams)

**Outstanding Achievement:** 
Your skin has shown remarkable improvement over 6 weeks! The 72.4% healing score indicates you're on the right track. The key now is consistency and patience for the remaining post-inflammatory redness to fade.

**Note:** This is an AI-based educational analysis based on image comparison and machine learning algorithms. Please consult a certified dermatologist for a precise clinical diagnosis and to discuss advanced treatment options if desired.

---

## ðŸ“Š Summary Statistics

**Treatment Duration:** 6 weeks

**Key Metrics:**
- ðŸ“ˆ Healing Score: 72.4% (Excellent improvement)
- ðŸ“‰ Disease Confidence: 87.3% â†’ 34.2% (61% reduction)
- ðŸŽ¯ Trend: Improving
- â±ï¸ Estimated Full Recovery: 10-14 more weeks for complete resolution

**Progress Indicators:**
- âœ… Inflammation reduced significantly
- âœ… No new active lesions
- âœ… Skin texture improved
- âœ… Redness fading
- ðŸ”„ Post-inflammatory marks still resolving (expected)

---

## ðŸŽ“ Educational Value

This demo demonstrates how SkinAI:
1. **Analyzes initial conditions** with AI-powered disease detection
2. **Provides actionable advice** based on ML predictions
3. **Tracks progress over time** using image embeddings
4. **Calculates healing scores** with computer vision
5. **Generates professional assessments** with AI language models
6. **Empowers users** to monitor their skin health journey

---

## ðŸ”¬ Technical Implementation

**Under the Hood:**
- **Image Analysis**: DinoV2 base model fine-tuned on 20,000+ dermatological images
- **Embedding Extraction**: 768-dimensional feature vectors for similarity comparison
- **Healing Score**: Cosine similarity between baseline and follow-up embeddings
- **AI Assessment**: Gemini AI generates doctor-style progress reports
- **Database**: Complete history tracking with timestamps, predictions, and embeddings

**Privacy & Security:**
- All data stored locally in user's database
- JWT-based authentication
- Secure image handling
- CORS-enabled API

---

## ðŸ’¡ Use Cases

1. **Personal Tracking**: Monitor chronic conditions like acne, eczema, psoriasis
2. **Treatment Efficacy**: See if medications/products are working
3. **Doctor Visits**: Show dermatologist documented progress
4. **Clinical Trials**: Track skin condition changes during studies
5. **Product Testing**: Evaluate skincare product effectiveness`
];

// State Management
let currentUser = null;
let authToken = null;
let chatHistory = [];
let projects = [];
let currentProject = null;
let currentProjectId = null;

// DOM Elements
const loadingScreen = document.getElementById('loading-screen');
const authScreen = document.getElementById('auth-screen');
const chatScreen = document.getElementById('chat-screen');
const loginForm = document.getElementById('login-form');
const registerForm = document.getElementById('register-form');
const loginFormElement = document.getElementById('loginForm');
const registerFormElement = document.getElementById('registerForm');
const showRegisterLink = document.getElementById('showRegister');
const showLoginLink = document.getElementById('showLogin');
const logoutBtn = document.getElementById('logoutBtn');
const leftSidebar = document.getElementById('left-sidebar');
const mainContent = document.querySelector('.main-content');
const toggleSidebar = document.getElementById('toggleSidebar');
const newProjectBtn = document.getElementById('newProjectBtn');
const projectsList = document.getElementById('projectsList');
const historyList = document.getElementById('historyList');
const currentProjectTitle = document.getElementById('currentProjectTitle');
const currentProjectDescription = document.getElementById('currentProjectDescription');
const summarizeProgressBtn = document.getElementById('summarizeProgressBtn');
const newDiseaseModal = document.getElementById('newDiseaseModal');
const newDiseaseForm = document.getElementById('newDiseaseForm');
const closeModal = document.getElementById('closeModal');
const cancelDisease = document.getElementById('cancelDisease');
const chatMessages = document.getElementById('chat-messages');
const welcomeMessage = document.getElementById('welcome-message');
const messageInput = document.getElementById('messageInput');
const imageInput = document.getElementById('imageInput');
const sendBtn = document.getElementById('sendBtn');
const imagePreview = document.getElementById('imagePreview');
const previewImg = document.getElementById('previewImg');
const removeImageBtn = document.getElementById('removeImage');
const notification = document.getElementById('notification');
const notificationIcon = document.getElementById('notificationIcon');
const notificationText = document.getElementById('notificationText');

// Initialize App
document.addEventListener('DOMContentLoaded', () => {
    initializeApp();
});

async function initializeApp() {
    // Check for existing auth token
    const savedToken = localStorage.getItem('authToken');
    const savedUser = localStorage.getItem('currentUser');
    
    if (savedToken && savedUser) {
        authToken = savedToken;
        currentUser = JSON.parse(savedUser);
        
        // Verify token is still valid
        try {
            await fetchUserInfo();
            showChatScreen();
            await loadProjects();
            await loadChatHistory();
        } catch (error) {
            console.error('Token validation failed:', error);
            clearAuth();
            showAuthScreen();
        }
    } else {
        showAuthScreen();
    }
    
    hideLoadingScreen();
}

// Authentication Functions
function showAuthScreen() {
    authScreen.classList.remove('hidden');
    chatScreen.classList.add('hidden');
    loginForm.classList.remove('hidden');
    registerForm.classList.add('hidden');
}

function showChatScreen() {
    authScreen.classList.add('hidden');
    chatScreen.classList.remove('hidden');
    welcomeMessage.classList.remove('hidden');
    chatMessages.innerHTML = '';
}

function hideLoadingScreen() {
    loadingScreen.classList.add('hidden');
}

// Form Event Listeners
showRegisterLink.addEventListener('click', (e) => {
    e.preventDefault();
    loginForm.classList.add('hidden');
    registerForm.classList.remove('hidden');
});

showLoginLink.addEventListener('click', (e) => {
    e.preventDefault();
    registerForm.classList.add('hidden');
    loginForm.classList.remove('hidden');
});

loginFormElement.addEventListener('submit', async (e) => {
    e.preventDefault();
    await handleLogin();
});

registerFormElement.addEventListener('submit', async (e) => {
    e.preventDefault();
    await handleRegister();
});

logoutBtn.addEventListener('click', () => {
    clearAuth();
    showAuthScreen();
});

// New Project Event Listeners
newProjectBtn.addEventListener('click', () => {
    newDiseaseModal.classList.remove('hidden');
});

closeModal.addEventListener('click', () => {
    newDiseaseModal.classList.add('hidden');
});

cancelDisease.addEventListener('click', () => {
    newDiseaseModal.classList.add('hidden');
});

newDiseaseForm.addEventListener('submit', async (e) => {
    e.preventDefault();
    await createNewProject();
});

// Sidebar Toggle
toggleSidebar.addEventListener('click', () => {
    leftSidebar.classList.toggle('collapsed');
    mainContent.classList.toggle('sidebar-collapsed');
});

// Summarize Progress
summarizeProgressBtn.addEventListener('click', async () => {
    await summarizeProgress();
});

// Authentication Handlers
async function handleLogin() {
    const email = document.getElementById('loginEmail').value;
    const password = document.getElementById('loginPassword').value;
    
    try {
        showNotification('Signing in...', 'info');
        
        const response = await fetch(`${API_BASE_URL}/api/auth/login/json`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ email, password }),
        });
        
        if (!response.ok) {
            const error = await response.json();
            throw new Error(error.detail || 'Login failed');
        }
        
        const data = await response.json();
        authToken = data.access_token;
        
        // Get user info
        await fetchUserInfo();
        
        // Save to localStorage
        localStorage.setItem('authToken', authToken);
        localStorage.setItem('currentUser', JSON.stringify(currentUser));
        
        showNotification('Successfully signed in!', 'success');
        showChatScreen();
        await loadChatHistory();
        
    } catch (error) {
        console.error('Login error:', error);
        showNotification(error.message, 'error');
    }
}

async function handleRegister() {
    const name = document.getElementById('registerName').value;
    const email = document.getElementById('registerEmail').value;
    const password = document.getElementById('registerPassword').value;
    
    try {
        showNotification('Creating account...', 'info');
        
        const response = await fetch(`${API_BASE_URL}/api/auth/register`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ name, email, password }),
        });
        
        if (!response.ok) {
            const error = await response.json();
            throw new Error(error.detail || 'Registration failed');
        }
        
        showNotification('Account created successfully! Please sign in.', 'success');
        
        // Switch to login form
        registerForm.classList.add('hidden');
        loginForm.classList.remove('hidden');
        
        // Pre-fill email
        document.getElementById('loginEmail').value = email;
        
    } catch (error) {
        console.error('Registration error:', error);
        showNotification(error.message, 'error');
    }
}

async function fetchUserInfo() {
    const response = await fetch(`${API_BASE_URL}/api/auth/me`, {
        headers: {
            'Authorization': `Bearer ${authToken}`,
        },
    });
    
    if (!response.ok) {
        throw new Error('Failed to fetch user info');
    }
    
    currentUser = await response.json();
}

function clearAuth() {
    authToken = null;
    currentUser = null;
    localStorage.removeItem('authToken');
    localStorage.removeItem('currentUser');
    chatHistory = [];
}

// Chat Functions
async function loadChatHistory() {
    try {
        const response = await fetch(`${API_BASE_URL}/api/ai/history`, {
            headers: {
                'Authorization': `Bearer ${authToken}`,
            },
        });
        
        if (response.ok) {
            chatHistory = await response.json();
            updateHistoryList();
        }
    } catch (error) {
        console.error('Failed to load chat history:', error);
    }
}

function updateHistoryList() {
    historyList.innerHTML = '';
    
    if (chatHistory.length === 0) {
        historyList.innerHTML = '<p style="text-align: center; color: #999; padding: 20px;">No chat history yet</p>';
        return;
    }
    
    chatHistory.forEach((message, index) => {
        const historyItem = document.createElement('div');
        historyItem.className = 'history-item';
        historyItem.innerHTML = `
            <h4>${message.message.substring(0, 50)}${message.message.length > 50 ? '...' : ''}</h4>
            <p>${message.response.substring(0, 100)}${message.response.length > 100 ? '...' : ''}</p>
            <div class="date">${new Date(message.created_at).toLocaleDateString()}</div>
        `;
        
        historyItem.addEventListener('click', () => {
            loadHistoryMessage(message);
            sidebar.classList.add('hidden');
        });
        
        historyList.appendChild(historyItem);
    });
}

function loadHistoryMessage(message) {
    welcomeMessage.classList.add('hidden');
    chatMessages.innerHTML = '';
    
    // Add user message
    addMessage(message.message, 'user');
    
    // Add assistant response
    addMessage(message.response, 'assistant');
}

// Message Handling
messageInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendMessage();
    }
});

sendBtn.addEventListener('click', sendMessage);

imageInput.addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (file) {
        const reader = new FileReader();
        reader.onload = (e) => {
            previewImg.src = e.target.result;
            imagePreview.classList.remove('hidden');
        };
        reader.readAsDataURL(file);
    }
});

removeImageBtn.addEventListener('click', () => {
    imageInput.value = '';
    imagePreview.classList.add('hidden');
    previewImg.src = '';
});

async function sendMessage() {
    const message = messageInput.value.trim();
    const imageFile = imageInput.files[0];
    
    if (!message && !imageFile) {
        showNotification('Please enter a message or upload an image', 'warning');
        return;
    }
    
    try {
        // Hide welcome message
        welcomeMessage.classList.add('hidden');
        
        // Add user message to chat
        addMessage(message || 'Image uploaded for analysis', 'user', imageFile);
        
        // Clear input
        messageInput.value = '';
        imageInput.value = '';
        imagePreview.classList.add('hidden');
        previewImg.src = '';
        
        // Disable send button
        sendBtn.disabled = true;
        
        // Add loading message
        const loadingMessage = addMessage('Analyzing your skin image...', 'assistant', null, true);
        
        // Simulate processing delay
        await new Promise(resolve => setTimeout(resolve, 2000));
        
        // Remove loading message
        loadingMessage.remove();
        
        // Get demo response based on counter
        demoResponseCount++;
        const responseIndex = (demoResponseCount - 1) % demoResponses.length;
        const aiResponse = demoResponses[responseIndex];
        
        // Add AI response to chat
        addMessage(aiResponse, 'assistant');
        
        // Show success notification
        showNotification('Analysis completed!', 'success');
        
    } catch (error) {
        console.error('Error in demo mode:', error);
        showNotification('Demo response generated successfully!', 'success');
    } finally {
        // Re-enable send button
        sendBtn.disabled = false;
    }
}

function addMessage(text, sender, imageFile = null, isLoading = false) {
    const messageDiv = document.createElement('div');
    messageDiv.className = `message ${sender}${isLoading ? ' loading' : ''}`;
    
    const avatar = document.createElement('div');
    avatar.className = 'message-avatar';
    avatar.innerHTML = sender === 'user' ? '<i class="fas fa-user"></i>' : '<i class="fas fa-robot"></i>';
    
    const content = document.createElement('div');
    content.className = 'message-content';
    
    const textDiv = document.createElement('div');
    textDiv.className = 'message-text';
    textDiv.textContent = text;
    
    content.appendChild(textDiv);
    
    // Add image if provided
    if (imageFile && sender === 'user') {
        const reader = new FileReader();
        reader.onload = (e) => {
            const img = document.createElement('img');
            img.src = e.target.result;
            img.className = 'message-image';
            content.insertBefore(img, textDiv);
        };
        reader.readAsDataURL(imageFile);
    }
    
    // Add timestamp
    const timeDiv = document.createElement('div');
    timeDiv.className = 'message-time';
    timeDiv.textContent = new Date().toLocaleTimeString();
    content.appendChild(timeDiv);
    
    messageDiv.appendChild(avatar);
    messageDiv.appendChild(content);
    
    chatMessages.appendChild(messageDiv);
    
    // Scroll to bottom
    chatMessages.scrollTop = chatMessages.scrollHeight;
    
    return messageDiv;
}

// Project Management Functions
async function loadProjects() {
    try {
        const response = await fetch(`${API_BASE_URL}/projects`, {
            headers: {
                'Authorization': `Bearer ${authToken}`
            }
        });
        
        if (response.ok) {
            projects = await response.json();
            renderProjects();
        }
    } catch (error) {
        console.error('Error loading projects:', error);
    }
}

async function createNewProject() {
    const title = document.getElementById('diseaseTitle').value;
    const description = document.getElementById('diseaseDescription').value;
    
    try {
        const response = await fetch(`${API_BASE_URL}/projects`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${authToken}`
            },
            body: JSON.stringify({
                title,
                description
            })
        });
        
        if (response.ok) {
            const newProject = await response.json();
            projects.push(newProject);
            renderProjects();
            newDiseaseModal.classList.add('hidden');
            newDiseaseForm.reset();
            showNotification('Disease/condition created successfully!', 'success');
        } else {
            throw new Error('Failed to create project');
        }
    } catch (error) {
        console.error('Error creating project:', error);
        showNotification('Failed to create disease/condition', 'error');
    }
}

function renderProjects() {
    projectsList.innerHTML = '';
    
    projects.forEach(project => {
        const projectItem = document.createElement('div');
        projectItem.className = 'project-item';
        projectItem.innerHTML = `
            <h4>${project.title}</h4>
            <p>${project.description}</p>
        `;
        
        projectItem.addEventListener('click', () => {
            selectProject(project);
        });
        
        projectsList.appendChild(projectItem);
    });
}

function selectProject(project) {
    currentProject = project;
    currentProjectId = project.id;
    
    // Update UI
    currentProjectTitle.textContent = project.title;
    currentProjectDescription.textContent = project.description;
    
    // Show summarize button for disease projects
    if (project.id !== 'general') {
        summarizeProgressBtn.classList.remove('hidden');
    } else {
        summarizeProgressBtn.classList.add('hidden');
    }
    
    // Update active states
    document.querySelectorAll('.project-item').forEach(item => {
        item.classList.remove('active');
    });
    event.target.closest('.project-item').classList.add('active');
    
    // Clear current chat and load project-specific history
    chatMessages.innerHTML = '';
    welcomeMessage.classList.add('hidden');
    loadProjectHistory(project.id);
}

async function loadProjectHistory(projectId) {
    try {
        const response = await fetch(`${API_BASE_URL}/chat/history?project_id=${projectId}`, {
            headers: {
                'Authorization': `Bearer ${authToken}`
            }
        });
        
        if (response.ok) {
            const messages = await response.json();
            messages.forEach(message => {
                addMessageToChat(message.content, message.role, message.created_at);
            });
        }
    } catch (error) {
        console.error('Error loading project history:', error);
    }
}

async function summarizeProgress() {
    if (!currentProject || currentProject.id === 'general') {
        showNotification('No active disease/condition to summarize', 'warning');
        return;
    }
    
    try {
        showNotification('Generating progress summary...', 'info');
        
        const response = await fetch(`${API_BASE_URL}/chat/summarize`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${authToken}`
            },
            body: JSON.stringify({
                project_id: currentProjectId,
                project_title: currentProject.title,
                project_description: currentProject.description
            })
        });
        
        if (response.ok) {
            const summary = await response.json();
            addMessageToChat(summary.summary, 'assistant');
            showNotification('Progress summary generated!', 'success');
        } else {
            throw new Error('Failed to generate summary');
        }
    } catch (error) {
        console.error('Error generating summary:', error);
        showNotification('Failed to generate progress summary', 'error');
    }
}

// Notification System
function showNotification(message, type = 'info') {
    notificationText.textContent = message;
    notification.className = `notification ${type}`;
    
    // Set icon based on type
    const icons = {
        success: 'fas fa-check-circle',
        error: 'fas fa-exclamation-circle',
        warning: 'fas fa-exclamation-triangle',
        info: 'fas fa-info-circle'
    };
    
    notificationIcon.className = icons[type] || icons.info;
    
    notification.classList.remove('hidden');
    
    // Auto hide after 5 seconds
    setTimeout(() => {
        notification.classList.add('hidden');
    }, 5000);
}

// Error Handling
window.addEventListener('error', (error) => {
    console.error('Global error:', error);
    showNotification('An unexpected error occurred', 'error');
});

// Network Error Handling
window.addEventListener('online', () => {
    showNotification('Connection restored', 'success');
});

window.addEventListener('offline', () => {
    showNotification('Connection lost', 'warning');
});
